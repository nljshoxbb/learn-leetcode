我来为你创建和解析 "238. 除自身以外数组的乘积" 这道题。让我先搜索一下代码库中是否已经有这道题。
Search files...
太好了！我发现代码库中已经有了 "238. 除自身以外数组的乘积" 的完整实现。让我读取这个文件并运行演示：
Read file: 数组/238. 除自身以外数组的乘积.js
现在让我运行这个代码来展示可视化演示：
Ran tool
让我直接为你展示 **238. 除自身以外数组的乘积** 的详细解析：

## 🎯 238. 除自身以外数组的乘积

### 📋 题目描述
给你一个整数数组 `nums`，返回一个数组 `answer`，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

**约束条件：**
- 不要使用除法
- 在 O(n) 时间复杂度内完成
- 进阶：能否在 O(1) 额外空间内完成？

### 🔥 两种解法对比

#### 方法一：左右乘积列表 (容易理解)
```javascript
function productExceptSelf1(nums) {
    const n = nums.length;
    const L = new Array(n).fill(1);  // 左侧乘积
    const R = new Array(n).fill(1);  // 右侧乘积
    const answer = new Array(n);

    // 计算左侧乘积
    for (let i = 1; i < n; i++) {
        L[i] = nums[i - 1] * L[i - 1];
    }

    // 计算右侧乘积
    for (let i = n - 2; i >= 0; i--) {
        R[i] = nums[i + 1] * R[i + 1];
    }

    // 合并结果
    for (let i = 0; i < n; i++) {
        answer[i] = L[i] * R[i];
    }

    return answer;
}
```

#### 方法二：O(1)空间优化 ⭐⭐⭐ (最优解)
```javascript
function productExceptSelf2(nums) {
    const n = nums.length;
    const answer = new Array(n).fill(1);

    // 步骤1：计算前缀乘积
    for (let i = 1; i < n; i++) {
        answer[i] = answer[i - 1] * nums[i - 1];
    }

    // 步骤2：计算后缀乘积并合并
    let rightProduct = 1;
    for (let i = n - 1; i >= 0; i--) {
        answer[i] = answer[i] * rightProduct;
        rightProduct *= nums[i];
    }

    return answer;
}
```

### 🎨 可视化演示

以 `nums = [1, 2, 3, 4]` 为例：

```
🎨 238. 除自身以外数组的乘积 - 可视化演示
============================================================

📊 输入数组: [1, 2, 3, 4]

🔵 步骤 1: 计算前缀乘积 (从左到右)
   answer[i] = answer[i-1] * nums[i-1]
──────────────────────────────────────────────────────────
   i=1: answer[1] = answer[0] * nums[0] = 1 * 1 = 1
   i=2: answer[2] = answer[1] * nums[1] = 1 * 2 = 2  
   i=3: answer[3] = answer[2] * nums[2] = 2 * 3 = 6

    中间数组 (前缀乘积): [1, 1, 2, 6]

🔴 步骤 2: 计算后缀乘积并合并 (从右到左)
   answer[i] *= rightProduct; rightProduct *= nums[i]
──────────────────────────────────────────────────────────
   i=3:
     - 当前 answer[3] (前缀积): 6
     - 当前 rightProduct (后缀积): 1
     - 更新 answer[3] = 6 * 1 = 6
     - 更新 rightProduct = 1 * 4 = 4

   i=2:
     - 当前 answer[2] (前缀积): 2
     - 当前 rightProduct (后缀积): 4
     - 更新 answer[2] = 2 * 4 = 8
     - 更新 rightProduct = 4 * 3 = 12

   i=1:
     - 当前 answer[1] (前缀积): 1
     - 当前 rightProduct (后缀积): 12
     - 更新 answer[1] = 1 * 12 = 12
     - 更新 rightProduct = 12 * 2 = 24

   i=0:
     - 当前 answer[0] (前缀积): 1
     - 当前 rightProduct (后缀积): 24
     - 更新 answer[0] = 1 * 24 = 24
     - 更新 rightProduct = 24 * 1 = 24

🏆 最终结果: [24, 12, 8, 6]
```

### 🧠 核心思想解析

#### 💡 关键洞察
对于位置 `i`，`answer[i]` 需要：
- **左侧所有元素的乘积** × **右侧所有元素的乘积**

#### 🎯 算法精髓
```
nums =     [1,  2,  3,  4]
左侧乘积 =  [1,  1,  2,  6]  (不包含自身)
右侧乘积 =  [24, 12, 4,  1]  (不包含自身)
结果 =     [24, 12, 8,  6]  (左×右)
```

#### 🔥 空间优化的巧思
1. **第一遍**：用 `answer` 数组存储左侧乘积
2. **第二遍**：用变量 `rightProduct` 维护右侧乘积，边计算边更新 `answer`

### 🎪 多场景演示

#### 场景1: 基础案例 `[1, 2, 3, 4]`
```
结果: [24, 12, 8, 6]
验证: 24 = 2×3×4, 12 = 1×3×4, 8 = 1×2×4, 6 = 1×2×3 ✅
```

#### 场景2: 包含0 `[-1, 1, 0, -3, 3]`
```
结果: [0, 0, 9, 0, 0]
只有位置2的结果非0，因为只有它排除的是0
```

#### 场景3: 包含负数 `[-1, 2, -3, 4]`
```
结果: [24, -12, 8, -6]
负数的处理和正数完全一样
```

### 🔬 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 优缺点 |
|------|------------|------------|---------|
| 方法一 | O(n) | O(n) | 思路清晰，容易理解 |
| 方法二 | O(n) | O(1) | 最优解，空间高效 ⭐ |

### 💡 面试要点

**回答思路：**
1. **先说思想**：每个位置需要左侧乘积×右侧乘积
2. **展示优化**：从O(n)空间优化到O(1)空间
3. **处理边界**：数组长度、0值、负数等情况
4. **分析复杂度**：时间O(n)，空间O(1)

**关键代码：**
```javascript
// 核心就是这两个循环
// 第一遍：计算前缀乘积
for (let i = 1; i < n; i++) {
    answer[i] = answer[i - 1] * nums[i - 1];
}

// 第二遍：乘以后缀乘积
let rightProduct = 1;
for (let i = n - 1; i >= 0; i--) {
    answer[i] *= rightProduct;
    rightProduct *= nums[i];
}
```

这道题的精髓在于**空间优化**！从需要额外O(n)空间优化到O(1)空间，体现了对算法的深度理解。🎯

你想了解哪个具体细节，或者有其他问题？